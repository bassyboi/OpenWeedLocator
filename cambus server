import sys
import socket
import threading
from PyQt5.QtWidgets import QApplication, QMainWindow, QPushButton, QLabel, QVBoxLayout, QWidget, QMessageBox, QHBoxLayout
from PyQt5.QtCore import pyqtSignal, QObject

# Define server host and port
SERVER_HOST = '127.0.0.1'
SERVER_PORT = 5000

# Define CAN bus command codes and their corresponding actions
CAN_COMMANDS = {
    "pause": 0x301,
    "play": 0x302,
    "boom_flush": 0x303,
    "stop": 0x304,
    "save_config": 0x305
}

# Error codes display
ERROR_CODES = {
    0x401: "Camera Error",
    0x402: "Relay Error",
    0x403: "Processing Error",
    0x404: "Configuration Error"
}

class ServerThread(QObject):
    # Custom signals for communication
    update_status_signal = pyqtSignal(str)
    update_error_signal = pyqtSignal(str)

    def __init__(self):
        super().__init__()
        self.server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        self.client_socket = None
        self.server_running = False

    def start_server(self):
        try:
            self.server_socket.bind((SERVER_HOST, SERVER_PORT))
            self.server_socket.listen(1)  # Listen for 1 client connection
            self.server_running = True
            threading.Thread(target=self.accept_client, daemon=True).start()
            self.update_status_signal.emit("Server started. Waiting for client connection...")
        except Exception as e:
            self.update_error_signal.emit(f"Server error: {e}")

    def accept_client(self):
        try:
            self.client_socket, addr = self.server_socket.accept()
            self.update_status_signal.emit(f"Client connected from {addr}")
            threading.Thread(target=self.handle_client, daemon=True).start()
        except Exception as e:
            self.update_error_signal.emit(f"Client connection error: {e}")

    def handle_client(self):
        while self.server_running:
            try:
                message = self.client_socket.recv(1024).decode()
                if message:
                    self.update_status_signal.emit(f"Received from client: {message}")
            except Exception as e:
                self.update_error_signal.emit(f"Error receiving data: {e}")
                break

    def send_command_to_client(self, command):
        if self.client_socket:
            try:
                self.client_socket.send(command.encode())
                self.update_status_signal.emit(f"Sent command to client: {command}")
            except Exception as e:
                self.update_error_signal.emit(f"Error sending data: {e}")
        else:
            self.update_error_signal.emit("No client connected.")

    def stop_server(self):
        self.server_running = False
        if self.client_socket:
            self.client_socket.close()
        self.server_socket.close()
        self.update_status_signal.emit("Server stopped.")


class OwlControllerApp(QMainWindow):
    def __init__(self):
        super().__init__()

        self.setWindowTitle("Owl System Control Panel (Server)")
        self.setGeometry(100, 100, 500, 300)

        # Initialize server thread
        self.server_thread = ServerThread()
        self.server_thread.update_status_signal.connect(self.update_status)
        self.server_thread.update_error_signal.connect(self.update_error)

        # Layout setup
        layout = QVBoxLayout()
        button_layout = QHBoxLayout()

        # Start Server Button
        self.start_server_button = QPushButton("Start Server")
        self.start_server_button.clicked.connect(self.start_server)
        layout.addWidget(self.start_server_button)

        # Stop Server Button
        self.stop_server_button = QPushButton("Stop Server")
        self.stop_server_button.clicked.connect(self.stop_server)
        layout.addWidget(self.stop_server_button)

        # CAN Command Buttons
        self.play_button = QPushButton("Play")
        self.play_button.clicked.connect(lambda: self.send_can_command("play"))
        button_layout.addWidget(self.play_button)

        self.pause_button = QPushButton("Pause")
        self.pause_button.clicked.connect(lambda: self.send_can_command("pause"))
        button_layout.addWidget(self.pause_button)

        self.boom_flush_button = QPushButton("Boom Flush")
        self.boom_flush_button.clicked.connect(lambda: self.send_can_command("boom_flush"))
        button_layout.addWidget(self.boom_flush_button)

        self.stop_command_button = QPushButton("Stop")
        self.stop_command_button.clicked.connect(lambda: self.send_can_command("stop"))
        button_layout.addWidget(self.stop_command_button)

        self.save_config_button = QPushButton("Save Config")
        self.save_config_button.clicked.connect(lambda: self.send_can_command("save_config"))
        button_layout.addWidget(self.save_config_button)

        layout.addLayout(button_layout)

        # Status Label
        self.status_label = QLabel("Server Status: Not running")
        layout.addWidget(self.status_label)

        # Error Message Label
        self.error_label = QLabel("Error: None")
        layout.addWidget(self.error_label)

        # Set layout to a central widget
        central_widget = QWidget()
        central_widget.setLayout(layout)
        self.setCentralWidget(central_widget)

    def start_server(self):
        self.server_thread.start_server()

    def stop_server(self):
        self.server_thread.stop_server()

    def send_can_command(self, command):
        can_command = CAN_COMMANDS.get(command)
        if can_command:
            self.server_thread.send_command_to_client(command)
        else:
            self.update_error(f"Invalid CAN command: {command}")

    def update_status(self, message):
        self.status_label.setText(message)

    def update_error(self, error_message):
        self.error_label.setText(f"Error: {error_message}")

def main():
    app = QApplication(sys.argv)
    mainWindow = OwlControllerApp()
    mainWindow.show()
    sys.exit(app.exec_())

if __name__ == "__main__":
    main()